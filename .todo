
creer objet user 
un truc pour stocker un moreceau de commande 

std::string line = "!avf Join #test,#bou,&coucou mo,na :oisj dgf oisd/r/n"; = > chercher CRLF
object user recupere la commande et la stocke dans l'objet commande - string buffer - ok

tableau de commandes dans user => std::queue ctr pours stocker les commandes - ok

pas de fd a gerer

pas de liste d'users - elle sera dans le server

tableau de responses pour le server std::queue = > "send" - ok
*les informations sur le user:
 		UserStatus status = ENUM;
		time_t last_ping;
		std::string hostaddr;
		std::string hostname;
		std::string nickname;
		std::string username;
		std::string realname;

		std::string mode;
		std::string pastnick;
		std::string lastChannel;
		std::string deleteMessage;
		std::string awayMessage;


faire la fonction write pour remplir le tableau des responses - ok

NE PAS FAIRE PUSH => server - ok

fonction dispatch - le traitement des commandes dans commande queue

***************************************************************
COMMAND CLASS
fonction reply avec user
void reply(User &user, unsigned short code, std::string*);

std::vector<std::string> array = {arg1, arg2, arg3, arg4, arg5, arg6, arg7};
/return command->reply(432, {nickname});
***************************************************************

liste des replies 

std::map<int, std::string (getReply*)(std::string*)> replies;


replies[205]->getReply(array)

void irc::Command::reply(User &user, unsigned short code, std::string arg1, std::string arg2, std::string arg3, std::string arg4, std::string arg5, std::string arg6, std::string arg7)
{
	std::stringstream sscode;
	sscode << code;
	std::string scode = sscode.str();
	while (scode.length() < 3)
		scode = "0" + scode;
	// std::vector<std::string> array;
	// array.push_back(arg1);
	// array.push_back(arg2);
	// array.push_back(arg3);
	// array.push_back(arg4);
	// array.push_back(arg5);
	// array.push_back(arg6);
	// array.push_back(arg7);
	user.sendTo(user, scode + " " + getReplies(code, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
}
void irc::Command::reply(unsigned short code, std::string arg1, std::string arg2, std::string arg3, std::string arg4, std::string arg5, std::string arg6, std::string arg7) { reply(*user, code, arg1, arg2, arg3, arg4, arg5, arg6, arg7); }


PASS - ok
NICK :
	Checker si un autre User a le même pseudo: ajouter un accès à la map d'user dans la commande ?
	Si collision return ERR_NICKCOLLISION
	Check charset autorisé - not completely ok
	
USER - ok

1. est-ce que user registered - dans Pass et User si user est registered or deja online
is oui - warning "deja registered"

2. checker si on peut faire plusieurs cmds pass et pour user

3. MODES user
